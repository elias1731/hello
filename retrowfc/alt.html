<!DOCTYPE html>
<html lang="de">
    <head>
        <title>RWFC ‚Ä¢ heyFordy.de</title>
        <meta name="description" content="Retro Rewind ist eine Custom Track-Distribution f√ºr Mario Kart Wii, erstellt von ZPL. Hier werden aktuelle Online-Daten der CT-Distro gezeigt."/>
        <meta name="author" content="heyFordy" />
        <meta name="keywords" content="mario kart wii, mkwii, retro rewind, zpl, rooms, online, status, online status, ctgp" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <link rel="icon" type="image/x-icon" href="./favicon.ico">
        <!-- <link rel="icon" type="image/png" href="./Logo.png"> -->
        <link rel="stylesheet" href="./style.css" type="text/css" />
        <link href="./ctmkf.css" rel="Stylesheet" type="text/css" />
        <link href="./Rubik.css" rel="Stylesheet" type="text/css" />
        <style>
            /* Ggf. ben√∂tigte Stile hinzuf√ºgen, z.B. */
            .excited { /* Beispiel */
                font-weight: bold;
            }
            .custom-highlighted { /* Beispiel */
                background-color: #a0a0ff; /* Beispiel-Farbe */
            }
            .room-header { /* Beispiel */
                text-align: left;
                padding: 10px;
                background-color: #333;
                border-top: 2px solid #555;
            }
            .room-link {
                color: #8af;
            }
            .joinable { color: lightgreen; }
            .not-joinable { color: red; }
            .split-room { color: yellow; }
            .mii-header, .mii-td { text-align: center; }
            .mii { background-color: #555; border-radius: 5px; }
            .wide-char { font-family: 'CTMKF', sans-serif; }
            td[openhost] { text-decoration: underline; }
            .guest-name { font-style: italic; color: #aaa; }
            #top-container { display: flex; justify-content: center; gap: 20px; font-size: 1.5em; margin-bottom: 10px; }
            #settings { margin-bottom: 20px; display: flex; flex-wrap: wrap; gap: 15px; justify-content: center; align-items: center; }
            #history-indicator { display: none; color: orange; }
            #not-found-container { display: none; color: red; font-size: 1.2em; text-align: center; margin: 20px;}
            #loading { text-align: center; margin: 20px; font-size: 1.2em; }
            body { font-family: 'Rubik', sans-serif; background-color: #1a1a1a; color: #eee; text-align: center; }
            table { width: 90%; margin: 20px auto; border-collapse: collapse; }
            th, td { border: 1px solid #444; padding: 5px; }
            th { background-color: #2a2a2a; }
            h1 { margin: 10px 0; }
            a { color: #69c; text-decoration: none; }
            a:hover { text-decoration: underline; }
            button { padding: 5px 10px; }
            input[type="text"], input[type="datetime-local"] { padding: 5px; }
            .highlighted { background-color: #442; } /* Farbe f√ºr hervorgehobenen FC */
        </style>
    </head>
    <body>
        <h1>
          <a href="?" id="home-link" decoding="async">
            <img src="RR.png" alt="Retro Rewind Server Status" style="height: 192px;" />
          </a>
        </h1>

        <div id="settings">
            <div id="timeout-container">
                <label for="timeout-checkbox">Automatisch aktualisieren</label>
                <input type="checkbox" id="timeout-checkbox" onchange="on_checkbox()" />
            </div>
            <div id="private-container">
                <label for="private-checkbox">Private R√§ume anzeigen</label>
                <input type="checkbox" id="private-checkbox" onchange="on_private_checkbox()" />
            </div>
            <div id="openhost-container">
                <label for="openhost-checkbox">Unterstreiche "OpenHost"</label>
                <input type="checkbox" id="openhost-checkbox" onchange="on_openhost_checkbox()" />
            </div>
            <div id="fc-container">
                <label for="fc-input">Spieler markieren:</label>
                <input type="text" id="fc-input" placeholder="0000-0000-0000-0000" oninput="on_fc_change()" />
            </div>
            <div id="history-container">
                <button onclick="add_history(-60)">-1h</button>
                <button onclick="add_history(-1)">-1m</button>
                <input type="datetime-local" id="history-input" oninput="on_history_change()" />
                <button onclick="add_history(1)">+1m</button>
                <button onclick="add_history(60)">+1h</button>
            </div>
            <div id="history-indicator">
                <span>Aktuell wird ein √§lterer Verlauf angezeigt.</span>
                <button onclick="disable_history()">Zur√ºck zum Live-Modus</button>
            </div>
        </div>

        <div id="loading">Daten werden geladen. Bitte warten...</div>

        <div id="top-container">
          <span><span id="no-players" class="top-stat excited">0</span> Spieler in</span>
          <span><span id="no-rooms" class="top-stat excited">0</span> R√§umen</span>
        </div></br>

        <div id="room-count-extra" style="font-size: 1.2em; margin-top: 2px;"></div>

        <div id="not-found-container">
            Angegebener Raum wurde geschlossen oder existiert nicht.
        </div>
        <table>
            <tbody id="tablebody"></tbody>
        </table>

        <p><a href="https://wiki.tockdom.com/wiki/Retro_Rewind" target="_blank">Retro Rewind</a> ist eine Custom Track Distribution f√ºr Mario Kart Wii, erstellt von ZPL.</p>
        <p>Diese Webseite wurde erstellt von <a href="https://github.com/KevinVG207" target="_blank">KevinVG207</a></p>
        <p>Raumdaten von <a href="http://rwfc.net/api/groups" target="_blank">diesem API Endpunkt</a>.</p>
        <p><a href="https://wiki.tockdom.com/wiki/CTMKF" target="_blank">Chadderz's Terrible Mario Kart Font</a> wird f√ºr die Mii-Namen-Sonderzeichen verwendet.</p>

        <script type="text/javascript">
            let HISTORY_TIMER = null;
            let HISTORY_MODE = false;
            let HISTORY_DATE = null;
            const MAX_MIIS_PER_REQUEST = 24;
            const EXPIRE_TIME = 1000 * 60 * 60 * 24 * 7; // 1 week
            const RELOAD_TIME = 1000 * 10; // 10 seconds
            let RELOAD_TIMER = null;
            let cur_rooms = [];
            let FIRST_LOAD = true;

            // ROOM_TYPES aus V2 (gemerged mit V1)
            const ROOM_TYPES = {
                "vs_10": { label: "üïπÔ∏è Retro VS", color: "orange" },
                "vs_11": { label: "‚è∞ Retro ZF", color: "darkorange" },
                "vs_12": { label: "üöÄ Retro 200cc", color: "orangered" },
                "vs_20": { label: "üöß Custom VS", color: "purple" },
                "vs_21": { label: "‚è∞ Custom ZF", color: "mediumpurple" },
                "vs_22": { label: "üí• Custom 200cc", color: "violet" },
                "vs_668": { label: "üèÅ CTGP-C", color: "limegreen" },
                "vs_69": { label: "üèÅ Insane Kart", color: "gray" },
                "vs_751": { label: "Standard VS_751", color: "gray" },
                "vs_-1": { label: "Standard VS", color: "gray" },
                "vs": { label: "Standard VS", color: "gray" },
                "vs_666": { label: "Luminous", color: "gray" },
                "vs_70": { label: "IKW Ultras VS", color: "gray" },
                "vs_71": { label: "IKW Crazy Items", color: "gray" },
                "vs_72": { label: "IKW Bob-omb Blast", color: "gray" },
                "vs_73": { label: "IKW Infinite Acceleration", color: "gray" },
                "vs_74": { label: "IKW Banana Slip", color: "gray" },
                "vs_75": { label: "IKW Random Items", color: "gray" },
                "vs_76": { label: "IKW Unfair Items", color: "gray" },
                "vs_77": { label: "IKW Blue Shell Madness", color: "gray" },
                "vs_78": { label: "IKW Mushroom Dash", color: "gray" },
                "vs_79": { label: "IKW Bumper Karts", color: "gray" },
                "vs_80": { label: "IKW Item Rampage", color: "gray" },
                "vs_81": { label: "IKW Item Rain", color: "gray" },
                "vs_82": { label: "IKW Shell Break", color: "gray" },
                "vs_83": { label: "IKW Riibalanced Stats", color: "gray" },
                "vs_875": { label: "OptPack VS", color: "gray" },
                "vs_876": { label: "OptPack TT", color: "gray" },
                "vs_877": { label: "OptPack", color: "gray" },
                "vs_878": { label: "OptPack", color: "gray" },
                "vs_879": { label: "OptPack", color: "gray" },
                "vs_880": { label: "OptPack", color: "gray" },
                "vs_1312": { label: "WTP 150cc", color: "gray" },
                "vs_1313": { label: "WTP 200cc", color: "gray" },
                "vs_1314": { label: "WTP TT", color: "gray" }
            };

            // Funktionen aus V1 (gr√∂√ütenteils beibehalten)
            function on_history_change() {
                if (HISTORY_TIMER){
                    clearTimeout(HISTORY_TIMER);
                }
                HISTORY_TIMER = setTimeout(change_history, 1000);
            }

            function add_history(minutes) {
                let history_input = document.getElementById("history-input");
                let history_time = new Date(history_input.value).getTime();
                history_time += minutes * 60 * 1000;
                let timezone_offset = new Date().getTimezoneOffset() * 60000;
                history_time -= timezone_offset;
                history_input.value = new Date(history_time).toISOString().slice(0, 16);
                on_history_change();
            }

            function change_history() {
                console.log("History mode enabled.");
                HISTORY_MODE = true;
                on_checkbox();
                fetch_rooms();
            }

            function disable_history() {
                HISTORY_MODE = false;
                let params = new URL(window.location.href).searchParams;
                params.delete("time");
                window.history.replaceState(null, null, `?${params.toString()}`);
                fetch_rooms()
            }

            function _escape(str){
                return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/(?:\r\n|\r|\n)/g, '');
            }

            function handle_mii_name(name){
                if (name.length > 10){
                    return name.substring(0, 10);
                }
                return filter_mii_name(_escape(name));
            }
            
            function char_code_is_wide(char_code){
                return (char_code >= 0xF103 && char_code <= 0xF12F) || char_code == 0x2026;
            }

            function filter_mii_name(name){
                let new_name = "";
                let special_char = false;
                for (let i = 0; i < name.length; i++){
                    const char_code = name.charCodeAt(i);
                    if (char_code_is_wide(char_code)){
                        if (!special_char){
                            new_name += "<span class=\"wide-char\">";
                            special_char = true;
                        }
                    } else {
                        if (special_char){
                            new_name += "</span>";
                            special_char = false;
                        }
                    }
                    new_name += name[i];
                }
                if (special_char){
                    new_name += "</span>";
                }
                return new_name;
            }

            function on_fc_change(){
                const fc = document.getElementById("fc-input").value;
                localStorage.setItem("highlight-fc", fc);
                reload_rooms();
            }

            function fix_split_rooms(rooms){ // V1 Logik
                let new_rooms = [];
                for (let room of rooms){
                    const player_keys = Object.keys(room.players);
                    room.split = false;
                    let player_data = [];
                    for (let i = 0; i < player_keys.length; i++){ player_data.push([]); }
                    for (let i = 0; i < player_keys.length; i++){
                        const player = room.players[player_keys[i]];
                        const conn_map = player.conn_map;
                        for (let j = 0; j < conn_map.length; j++){
                            if (conn_map[j] != "0"){
                                let their_idx = j;
                                if (their_idx >= i){ their_idx += 1; }
                                player_data[i].push(their_idx);
                            }
                        }
                    }
                    let seen_players = [];
                    let sub_rooms = [];
                    for (let i = 0; i < player_data.length; i++){
                        if (seen_players.indexOf(i) != -1){ continue; }
                        let new_room = JSON.parse(JSON.stringify(room));
                        new_room.players = {};
                        let new_players_idx = [];
                        let player_idx = i;
                        function recursive_add(idx){
                            if (seen_players.indexOf(idx) != -1){ return; }
                            seen_players.push(idx);
                            let cur_connected = player_data[idx];
                            for (const connected_idx of cur_connected){
                                if (player_data[connected_idx].indexOf(idx) == -1){ continue; }
                                recursive_add(connected_idx);
                            }
                            new_players_idx.push(idx);
                        }
                        recursive_add(player_idx);
                        new_players_idx.sort((a, b) => a - b);
                        for (const idx of new_players_idx){
                            new_room.players[player_keys[idx]] = room.players[player_keys[idx]];
                        }
                        sub_rooms.push(new_room);
                    }
                    if (sub_rooms.length > 1){
                        sub_rooms.forEach((sub_room) => {
                            sub_room.split = true;
                            if (Object.keys(room.players)[0] in sub_room.players){ sub_room.split = false; }
                        });
                        let fc = document.getElementById("fc-input").value;
                        if (fc){
                            let tmp = [];
                            for (let i = 0; i < sub_rooms.length; i++){
                                const room = sub_rooms[i];
                                let found = false;
                                for (const player_idx of Object.keys(room.players)){
                                    const player = room.players[player_idx];
                                    if (player.fc == fc){
                                        tmp.unshift(room);
                                        found = true;
                                        break;
                                    }
                                }
                                if (!found){ tmp.push(room); }
                            }
                            sub_rooms = tmp;
                        }
                        new_rooms = new_rooms.concat(sub_rooms);
                    } else {
                        new_rooms.push(room);
                    }
                }
                return new_rooms;
            }

            function filter_fc(rooms){ // V1 Logik
                const fc = localStorage.getItem("highlight-fc");
                if (!fc){ return rooms; }
                let new_rooms = [];
                for (let i = 0; i < rooms.length; i++){
                    const room = rooms[i];
                    let found = false;
                    for (const player_idx of Object.keys(room.players)){
                        const player = room.players[player_idx];
                        if (player.fc == fc){
                            new_rooms.unshift(room);
                            found = true;
                            break;
                        }
                    }
                    if (!found){ new_rooms.push(room); }
                }
                return new_rooms;
            }

            let prev_uptime_update_date = null;
            let uptimes_timer = null;

            function update_uptimes(skip_reset = false){
                const time_spans = document.querySelectorAll("span[created]");
                if (!HISTORY_MODE || skip_reset || FIRST_LOAD){
                    FIRST_LOAD = false;
                    for (const time_span of time_spans){
                        const created = new Date(time_span.getAttribute("created"));
                        let now = HISTORY_MODE ? HISTORY_DATE : new Date();
                        const diff = now - created;
                        let seconds = Math.floor(diff / 1000);
                        let minutes = Math.floor(seconds / 60);
                        let hours = Math.floor(minutes / 60);
                        let days = Math.floor(hours / 24);
                        hours %= 24; minutes %= 60; seconds %= 60;
                        let str = `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
                        if (days > 0){ str = `${days}:${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`; }
                        time_span.textContent = str;
                    }
                }
                if (skip_reset){ return; }
                var timeout_ms = 1000 - (prev_uptime_update_date ? (Date.now() - prev_uptime_update_date) : 0);
                prev_uptime_update_date = Date.now();
                if (uptimes_timer){ clearTimeout(uptimes_timer); }
                uptimes_timer = setTimeout(update_uptimes, Math.max(0, timeout_ms));
            }

            function on_checkbox(){
                if (document.getElementById("timeout-checkbox").checked){
                    if (RELOAD_TIMER){ clearInterval(RELOAD_TIMER); }
                    RELOAD_TIMER = setInterval(HISTORY_MODE ? on_checkbox : fetch_rooms, RELOAD_TIME);
                } else {
                    if (RELOAD_TIMER){ clearInterval(RELOAD_TIMER); }
                }
                localStorage.setItem("auto-reload", document.getElementById("timeout-checkbox").checked);
            }

            function on_private_checkbox() {
                localStorage.setItem("show-private", document.getElementById("private-checkbox").checked);
                reload_rooms();
            }

            function on_openhost_checkbox() {
                localStorage.setItem("openhost", document.getElementById("openhost-checkbox").checked);
                update_openhost_underline();
            }

            function update_openhost_underline() {
                let openhost_status = document.getElementById("openhost-checkbox").checked;
                document.querySelectorAll("td[openhost]").forEach((td) => {
                    td.classList.toggle("openhost", openhost_status);
                });
            }

            function remove_expired_mii_images(){
                let remove_keys = [];
                for (let i = 0; i < localStorage.length; i++){
                    const key = localStorage.key(i);
                    if (key.startsWith("mii_")){
                        const mii_data = JSON.parse(localStorage.getItem(key));
                        if (Date.now() - mii_data[1] > EXPIRE_TIME){ remove_keys.push(key); }
                    }
                }
                for (const key of remove_keys){ localStorage.removeItem(key); }
            }

            function get_cached_mii_image(mii_data){
                const mii_data_str = localStorage.getItem(`mii_${mii_data}`);
                if (!mii_data_str){ return null; }
                const mii_data_arr = JSON.parse(mii_data_str);
                if (Date.now() - mii_data_arr[1] > EXPIRE_TIME){
                    localStorage.removeItem(`mii_${mii_data}`);
                    return null;
                }
                return mii_data_arr[0];
            }

            function set_cached_mii_image(mii_data, mii_image){
                localStorage.setItem(`mii_${mii_data}`, JSON.stringify([mii_image, Date.now()]));
            }

            function apply_mii_image(mii_data, mii_image){
                set_cached_mii_image(mii_data, mii_image);
                document.querySelectorAll(`img[mii-data="${mii_data}"]`).forEach(img => img.src = mii_image);
            }

            async function fetch_mii_images(mii_data_list){
                let new_mii_data_list = [];
                for (const mii_data of mii_data_list){
                    let mii_image = get_cached_mii_image(mii_data);
                    if (mii_image){ apply_mii_image(mii_data, mii_image); } 
                    else { new_mii_data_list.push(mii_data); }
                }
                while (new_mii_data_list.length > 0){
                    let chunk = new_mii_data_list.splice(0, MAX_MIIS_PER_REQUEST);
                    try {
                        const mii_data_response = await fetch("https://umapyoi.net/api/v1/mii", {
                            method: "POST",
                            body: JSON.stringify(chunk)
                        });
                        if (!mii_data_response.ok){ console.log("Error fetching Mii data"); continue; }
                        const mii_dict = await mii_data_response.json();
                        for (const mii_data of Object.keys(mii_dict)){
                            apply_mii_image(mii_data, mii_dict[mii_data]);
                        }
                    } catch (e) {
                        console.log("Error fetching Mii data:", e);
                    }
                }
            }

            async function on_load(){
                document.getElementById("timeout-checkbox").checked = localStorage.getItem("auto-reload") == "true";
                document.getElementById("fc-input").value = localStorage.getItem("highlight-fc") || "";
                document.getElementById("private-checkbox").checked = localStorage.getItem("show-private") !== "false"; // Default true
                document.getElementById("openhost-checkbox").checked = localStorage.getItem("openhost") !== "false"; // Default true
                
                const params = new URL(window.location.href).searchParams;
                const timestamp = params.get("time");
                if (timestamp){
                    HISTORY_MODE = true;
                    let timezone_offset = new Date().getTimezoneOffset() * 60000;
                    HISTORY_DATE = new Date(parseInt(timestamp) * 1000 - timezone_offset);
                    document.getElementById("history-input").value = HISTORY_DATE.toISOString().slice(0, 16);
                    change_history();
                } else {
                    fetch_rooms();
                }
                on_checkbox(); // Start timer if checked
            }

            async function fetch_rooms() {
                console.log("Loading data...");
                remove_expired_mii_images();
                let checkbox = document.getElementById("timeout-checkbox");
                let history_indicator = document.getElementById("history-indicator");
                let timestamp_part = "";

                if (HISTORY_MODE){
                    let datetime = document.getElementById("history-input").value;
                    let history_time = Math.max(0, new Date(datetime).getTime());
                    HISTORY_DATE = new Date(isNaN(history_time) ? 0 : history_time);
                    let unix_seconds = Math.floor(HISTORY_DATE.getTime() / 1000);
                    let params = new URL(window.location.href).searchParams;
                    params.set("time", unix_seconds);
                    window.history.replaceState(null, null, `?${params.toString()}`);
                    timestamp_part = `/${unix_seconds}`;
                    checkbox.disabled = true;
                    history_indicator.style.display = "block";
                    document.getElementById("tablebody").innerHTML = "";
                    document.querySelector("#top-container").style.display = "none";
                    document.querySelector("#loading").style.display = "block";
                } else {
                    checkbox.disabled = false;
                    history_indicator.style.display = "none";
                }
                
                try {
                    const response = await fetch("https://umapyoi.net/api/v1/rr-rooms" + timestamp_part);
                    if (!response.ok){ console.log("Error fetching room data"); return; }
                    let rooms_data = await response.json();
                    let date = new Date();
                    let rooms;
                    if (HISTORY_MODE) {
                        date = new Date(rooms_data.timestamp * 1000);
                        rooms = rooms_data.data;
                    } else {
                        rooms = rooms_data;
                    }
                    cur_rooms = rooms;
                    reload_rooms();
                    let timezone_offset = date.getTimezoneOffset() * 60000;
                    document.getElementById("history-input").value = new Date(date.getTime() - timezone_offset).toISOString().slice(0, 16);
                } catch (e) {
                     console.log("Error fetching room data:", e);
                     document.querySelector("#loading").textContent = "Fehler beim Laden der Daten.";
                }
            }

            async function reload_rooms(){
                let rooms = cur_rooms;
                let no_players = 0;
                // console.log(rooms);

                const tbody = document.getElementById("tablebody");
                // Clear table
                tbody.innerHTML = "";

                const url = new URL(window.location.href);
                const params = url.searchParams;
                const filter_room = params.get("room");
                let room_not_found = true;

                rooms = filter_fc(rooms);
                rooms = fix_split_rooms(rooms);

                let rooms_count = 0;

                for (const room of rooms) {
                    if (filter_room && room.id != filter_room){
                        continue;
                    }

                    if (!filter_room && !document.getElementById("private-checkbox").checked && room.type != "anybody"){
                        continue;
                    }
                    
                    rooms_count += 1;
                    room_not_found = false;

                    // Raum Info
                    let tr = document.createElement("tr");
                    let room_header = document.createElement("th");
                    room_header.colSpan = 100;
                    room_header.classList.add("room-header");
                    let room_type = room.type == "anybody" ? "üåé √ñFFENTLICH ¬ª" : "üîí¬ª PRIVAT";


                    let joinable = room.suspend ? "Kein Beitritt m√∂glich!" : "Beitritt m√∂glich";
                    if (room.split) {
                        joinable = "Aufgeteilter Raum";
                    }

                    let joinable_class = room.suspend ? "not-joinable" : "joinable";
                    if (room.split) {
                        joinable_class = "split-room";
                    }

                    let room_no_players = 0;
                    tr.appendChild(room_header);
                    tbody.appendChild(tr);

                    // Data Headers
					tr = document.createElement("tr");
                    tr.classList.add("data-header");
                    tbody.appendChild(tr);
                    
                    // Mii
                    th = document.createElement("th");
                    th.textContent = "Mii";
                    th.classList.add("mii-header");
                    tr.appendChild(th);

                    // Mii-Name
                    th = document.createElement("th");
                    th.textContent = "Mii-Name";
                    th.colSpan = 2;
                    tr.appendChild(th);

                    // Freundescode
                    th = document.createElement("th");
                    th.textContent = "Freundescode";
                    tr.appendChild(th);

                    // // Connection fail
                    // th = document.createElement("th");
                    // th.textContent = "Conn\r\nFail";
                    // th.classList.add("conn-fail");
                    // tr.appendChild(th);

                    // VR
                    th = document.createElement("th");
                    th.textContent = "VR";
                    tr.appendChild(th);

                    // BR
                    th = document.createElement("th");
                    th.textContent = "BR";
                    tr.appendChild(th);

                    // Players
                    for (const player_idx of Object.keys(room.players)) {
                        let mii_idx = 0;
                        let no_miis = 1;

                        if ('mii' in room.players[player_idx]){
                            no_miis = room.players[player_idx].mii.length;
                        }

                        for (let cur_mii_idx = 0; cur_mii_idx < no_miis; cur_mii_idx++){
                            no_players++;
                            room_no_players++;

                            tr = document.createElement("tr");
                            tbody.appendChild(tr);

                            const Spieler = room.players[player_idx];

                            // Mii-Name
                            td = document.createElement("td");
                            td.classList.add("mii-td");
                            img = document.createElement("img");
                            img.width = 64;
                            img.height = 64;
                            img.alt = "Mii";
                            img.classList.add("mii");
                            img.src = "empty.png";
                            td.appendChild(img);
                            tr.appendChild(td);

                            // Mii-Name
                            let td_name = document.createElement("td");
                            td_name.colSpan = 2;
                            let name_ele = td_name;

                            if (cur_mii_idx > 0){
                                name_ele = document.createElement("td");
                                name_ele.classList.add("guest-name");
                                td_name.classList.add("guest-td");
                                td_name.colSpan = 1;
                                name_ele.colSpan = 1;

                                if (Object.keys(room.players).indexOf(player_idx) == Object.keys(room.players).length - 1 || cur_mii_idx < no_miis - 1){
                                    td_name.style.borderBottom = "hidden";
                                }
                            }

                            name_ele.classList.add("mii-name");
                            name_ele.innerHTML = handle_mii_name('mii' in Spieler ? Spieler.mii[cur_mii_idx].name : Spieler.name);
                            tr.appendChild(td_name);

                            if (cur_mii_idx > 0){
                                tr.appendChild(name_ele);
                            }
                            if ('mii' in Spieler){
                                img.setAttribute("mii-data", Spieler.mii[cur_mii_idx].data);
                            }

                            // Freundescode
                            td = document.createElement("td");
                            td.textContent = cur_mii_idx == 0 ? Spieler.fc : "Gast";
                            // if (cur_mii_idx == 0 && player_idx == room.host){
                            //     td.style.fontWeight = "bold";
                            // }

                            if (Spieler.fc == localStorage.getItem("highlight-fc")){
                                tr.classList.add("highlighted");
                            }
                            if (Spieler.fc == "4466-7667-0997"){
                                tr.classList.add("custom-highlighted");
                            }

                            if (Spieler.fc == "3092-3771-7526"){
                                tr.classList.add("custom-highlighted");
                            }

                            if (Spieler["openhost"] && Spieler.openhost == "true" && cur_mii_idx == 0) {
                                td.setAttribute("openhost", "");
                                td.title = "OpenHost enabled";
                            }

                            tr.appendChild(td);

                            // // Connection fail
                            // td = document.createElement("td");
                            // td.textContent = cur_mii_idx == 0 ? Spieler.conn_fail : "--";
                            // tr.appendChild(td);

                            // VR
                            td = document.createElement("td");
                            td.textContent = cur_mii_idx == 0 ? Spieler.ev : "";
                            tr.appendChild(td);

                            // BR
                            td = document.createElement("td");
                            td.textContent = cur_mii_idx == 0 ? Spieler.eb : "";
                            tr.appendChild(td);
                        }

                    // Room Header Text
                    var rk = room.rk;
                    if (rk && rk in ROOM_TYPES){
                        const type = ROOM_TYPES[rk];
                        rk = `<span title="${rk}" style="color: ${type.color};">${type.label}</span>`;
                    } else if (rk) { rk = rk.toUpperCase(); }
                    let room_link = `?room=${room.id}`; // Simpler link
                    room_header.innerHTML = `${room_type} ${rk? rk + " " : ""} | ${room_no_players} Spieler | Raum: <a href="${room_link}" class="room-link">${room.id}</a> | <span class="${joinable_class}">${joinable}</span> | aktiv seit: <span created="${room.created}"></span>`;
                    update_uptimes(!!uptimes_timer); // Update uptime, skip reset if timer exists
                }

                // Update Counts & Visibility
                document.querySelector("#loading").style.display = "none";
                document.querySelector("#top-container").style.display = filter_room ? "none" : "flex";
                document.querySelector("#not-found-container").style.display = room_not_found ? "block" : "none";

                if (!filter_room){
                    document.querySelector("#no-rooms").textContent = rooms_count;
                    document.querySelector("#no-players").textContent = no_players;

                    // Update room-count-extra
                    const retroRooms = rooms.filter(room => room.rk === 'vs_10').length;
                    const customRooms = rooms.filter(room => room.rk === 'vs_20').length;
                    const showPrivate = document.getElementById("private-checkbox").checked;
                    const otherRooms = rooms.filter(r => !['vs_10', 'vs_20'].includes(r.rk) && (r.type === 'anybody' || showPrivate)).length;
                    document.getElementById('room-count-extra').innerHTML = `
                      <span style="color: white; font-weight: bold">${retroRooms}</span> <span style="color: orange;">Retro</span> ‚Ä¢
                      <span style="color: white; font-weight: bold">${customRooms}</span> <span style="color: purple;">Custom</span> ‚Ä¢
                      <span style="color: white; font-weight: bold">${otherRooms}</span> <span style="color: gray;">Sonstige</span>`;
                }

                update_openhost_underline();
                fetch_mii_images(Array.from(document.querySelectorAll("img[mii-data]")).map(img => img.getAttribute("mii-data")));
            }

            // Init
            if (document.addEventListener) document.addEventListener('DOMContentLoaded', on_load, false);
            else window.onload = on_load; // Changed to on_load to ensure settings are loaded first
        </script>
    </body>
</html>