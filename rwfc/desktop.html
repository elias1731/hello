<!DOCTYPE html>
<html lang="en">
    <head>
        <title>üèéÔ∏è RWFC Rooms ‚Ä¢ heyFordy.de</title>
        <meta name="description" content="Retro Rewind ist eine Custom Track-Distribution f√ºr Mario Kart Wii, erstellt von ZPL. Hier werden aktuelle Online-Daten der CT-Distro gezeigt."/>
        <meta name="author" content="heyFordy" />
        <link rel="icon" href="./favicon.ico" sizes="any" />
        <meta name="mobile-web-app-capable" content="yes"></meta>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="keywords" content="mario kart wii, mkwii, retro rewind, zpl, rooms, online, status, online status, ctgp" />
        <link rel="icon" type="image/x-icon" href="./favicon.ico">
        <link rel="stylesheet" href="./style.css" type="text/css" />
        <link href="./ctmkf.css" rel="Stylesheet" type="text/css" />
        <link href="./Rubik.css" rel="Stylesheet" type="text/css" />
        
        <style type="text/css">
            /* Header layout fix */
            header {
                flex-wrap: wrap; 
                justify-content: space-between;
                padding: 15px 30px; /* More padding */
            }
            header h1 {
                order: 1; 
                font-size: 2.2em; /* Larger title */
            }
            header #settings-btn {
                order: 2; 
            }
            
            /* Header stats flipper */
            #header-stats {
                flex-basis: 100%; 
                text-align: center;
                font-size: 1.6em; /* Increased font size */
                font-weight: 300;
                color: var(--text-color, #FFF);
                opacity: 0.8;
                height: 1.2em; 
                margin-top: -5px; /* Adjusted spacing */
                padding-bottom: 5px;
                order: 3; 
            }
            #header-stats.hidden {
                display: none;
            }
            #header-stats span {
                transition: opacity 0.3s ease-in-out; /* Added fade transition */
            }
            #header-stats .excited {
                animation: excited 1s infinite;
                display: inline-block;
                font-weight: bold;
                color: var(--room-player-count-color, #FFF); 
            }

            /* Larger base font */
            body {
                font-size: 1.1em; 
            }

            /* Main container for desktop layout */
            main {
                max-width: none; /* Allow full width */
                padding: 20px;
            }

            /* Flexbox layout for room cards */
            #rooms-container {
                display: flex;
                flex-direction: row; /* Override style.css column */
                flex-wrap: wrap;
                justify-content: center; /* Center the cards */
                gap: 20px; /* Space between cards */
            }

            /* Fixed width for room cards */
            .room-card {
                width: 420px; 
                flex-grow: 0;
                flex-shrink: 0;
            }

            /* Larger text in cards */
            .room-card-header .room-name {
                font-size: 1.3em;
            }
            .room-details {
                font-size: 1.1em;
                padding: 12px 15px;
            }
            
            /* Player row adjustments */
            .player-row {
                padding: 10px 15px; /* More spacing */
            }
            .player-mii {
                width: 48px; /* Larger Miis */
                height: 48px;
            }
            .player-info {
                margin-left: 15px;
            }
            .player-name {
                font-size: 1.15em; 
            }
            .player-fc {
                font-size: 0.95em; 
            }
            .player-vrbr {
                font-size: 1.1em; 
            }

            /* Footer adjustments */
            .footer-links {
                font-size: 1.0em;
                padding: 20px;
            }
            
            /* Status text */
            #loading, #not-found-container {
                font-size: 1.2em;
                padding: 40px;
            }
        </style>
    </head>
    <body>
        
        <header>
            <h1><img src="./favicon.ico" alt="Favicon" class="header-favicon"> Retro Rewind üèéÔ∏è</h1>
            <div id="header-stats" class="hidden">
                <span id="header-stats-rooms" style="display: none;"></span>
                <span id="header-stats-players" style="display: none;"></span>
            </div>
            <button id="settings-btn">‚öô</button>
        </header>

        <div id="history-indicator" style="display: none;">
           <span style="font-style: normal;">‚ÑπÔ∏è</span> Currently viewing history.
           <button onclick="disable_history()">Back to Live</button>
        </div>

        <div id="filter-indicator" style="display: none;">
            <span style="font-style: normal;">‚ÑπÔ∏è</span> Room filter applied.
            <button onclick="disable_filter()">Show all</button>
        </div>

        <main>
            <div id="loading">‚è≥ Loading data. Please wait...</div>
            <div id="not-found-container" style="display: none;">
                The specified room was closed or does not exist.
            </div>
            <div id="rooms-container"></div>
        </main>

        <div id="settings-modal" class="hidden">
            <div id="settings-content">
                <h2>Settings</h2>
        
                <div id="theme-container">
                    <label for="theme-select">Theme:</label>
                    <select id="theme-select" onchange="on_theme_change()">
                        <option value="orange">Orange (Default)</option>
                        <option value="blue">Blue</option>
                        <option value="dark">Dark</option>
                    </select>
                </div>

                <div id="header-stats-container">
                    <label for="header-stats-checkbox">Show room/player count in header</label>
                    <input type="checkbox" id="header-stats-checkbox" onchange="on_header_stats_change()" />
                </div>
                
                <div id="sort-order-container">
                    <label for="sort-order-select">Sort rooms by:</label>
                    <select id="sort-order-select" onchange="on_sort_order_change()">
                        <option value="player_count">Player count</option>
                        <option value="time_created">Time created</option>
                    </select>
                </div>
                
                <div id="timeout-container">
                    <label for="timeout-checkbox">Auto-Refresh</label>
                    <input type="checkbox" id="timeout-checkbox" onchange="on_checkbox()" />
                </div>
                
                <div id="private-container">
                    <label for="private-checkbox">Show Private Rooms</label>
                    <input type="checkbox" id="private-checkbox" onchange="on_private_checkbox()" />
                </div>
                
                <div id="openhost-container">
                    <label for="openhost-checkbox">Underline "OpenHost"</label>
                    <input type="checkbox" id="openhost-checkbox" onchange="on_openhost_checkbox()" />
                </div>
                
                <div id="vr-only-container">
                    <label for="vr-only-checkbox">Only VR-points</label>
                    <input type="checkbox" id="vr-only-checkbox" onchange="on_vr_only_change()" />
                </div>
                
                <div id="fc-container">
                    <label for="fc-input">Highlight FC:</label>
                    <input type="text" id="fc-input" placeholder="0000-0000-0000" oninput="on_fc_change()" />
                </div>
                
                <div id="history-container">
                    <label for="history-input">History:</label>
                    <input type="datetime-local" id="history-input" oninput="on_history_change()" />
                <br></div>
                
                <div id="history-container">
                    <button onclick="add_history(-60)">-1h</button>
                    <button onclick="add_history(-1)">-1m</button>
                    <button onclick="add_history(1)">+1m</button>
                    <button onclick="add_history(60)">+1h</button>
                </div>
        
                <button id="close-settings">Save</button>
        
            </div>
        </div>        

        <div class="footer-links">
            <p>
                <a href="https://api.heyfordy.de/rwfc" target="_blank" class="footer-button">
                    API
                </a>
            </p>
            <p>
                <a href="https://github.com/patchzyy/WheelWizard" target="_blank" class="footer-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="footer-icon"><path d="M12 12m-9 0a9 9 0 1 0 18 0a9 9 0 1 0 -18 0"></path><path d="M12 12m-2 0a2 2 0 1 0 4 0a2 2 0 1 0 -4 0"></path><path d="M12 14l0 7"></path><path d="M10 12l-6.75 -2"></path><path d="M14 12l6.75 -2"></path></svg>
                    WheelWizard 
                    <span id="ww-version"> v?.?.?</span>
                </a>
            </p>
            <p>
                <a href="https://github.com/Bitte-ein-Git/rr_app" target="_blank" class="footer-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="footer-icon"><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .5 -.6 1.2 -.6 2.2v3.5"></path></svg>
                    Bitte ein Git!üçª
                </a>
            </p>
            <p>
                <a href="https://wiki.tockdom.com/wiki/Retro_Rewind" target="_blank" class="footer-button wiki-link">
                    Wiki - Retro Rewind 
                    <span id="rr-version"> v?.?.?</span>
                </a>
            </p>
            <p>
                <a href="https://heyfordy.de/" target="_blank" class="footer-button">
                    üóø ‚Ä¢ heyFordy.de
                </a>
            </p>
            <p><a href="https://wiki.tockdom.com/wiki/CTMKF" target="_blank">Font "CTMKF"</a></p>
            <p><a href="https://www.fontsquirrel.com/fonts/rubik" target="_blank">Font "Rubik"</a></p></br></br>
        </div>

        </br>
        <script type="text/javascript">
            // helper function
            const el = (id) => document.getElementById(id);
            
            // close menus on outside click
            document.addEventListener('click', () => {
                document.querySelectorAll('.player-menu').forEach(menu => {
                    menu.style.display = 'none';
                });
            });

            // toggle player menu
            function toggle_player_menu(menuElement) {
                // hide all other menus
                document.querySelectorAll('.player-menu').forEach(menu => {
                    if (menu !== menuElement) {
                        menu.style.display = 'none';
                    }
                });
                // toggle current menu
                const currentDisplay = menuElement.style.display || 'none';
                menuElement.style.display = (currentDisplay === 'none') ? 'block' : 'none';
            }

            // set highlight fc
            function set_highlight_fc(fc) {
                document.getElementById("fc-input").value = fc;
                on_fc_change();
            }

            // remove highlight fc
            function remove_highlight_fc() {
                document.getElementById("fc-input").value = "";
                on_fc_change();
            }

            // open player stats
            function open_player_stats(fc) {
                window.open(`https://rwfc.net/player/${fc}`, '_blank');
            }

            let HISTORY_TIMER = null;
            let HISTORY_MODE = false;
            let HISTORY_DATE = null;
            const MAX_MIIS_PER_REQUEST = 24;
            const EXPIRE_TIME = 1000 * 60 * 60 * 24 * 7;
            const RELOAD_TIME = 1000 * 5;
            let RELOAD_TIMER = null;
            let cur_rooms = [];
            let FIRST_LOAD = true;
            let VRBR_FLIPPER_TIMER = null;
            let VRBR_STATE = 'vr';
            let HEADER_STATS_FLIPPER_TIMER = null;
            let HEADER_STATS_STATE = 'rooms';

            // room types definition
            const ROOM_TYPES = {
                "10": { label: "üïπÔ∏è Retro Tracks", color: "#FF8C00" },
                "11": { label: "‚è∞ Online TT", color: "#FF6347" },
                "12": { label: "üöÄ 200cc", color: "#DC143C" },
                "13": { label: "‚òÇÔ∏è Item Rain", color: "#1E90FF" },
                "14": { label: "Regular Battle", color: "#B22222" },
                "15": { label: "Elimination Battle", color: "#8B0000" },
                "20": { label: "üöß Custom Tracks", color: "#8A2BE2" },
                "21": { label: "Vanilla Tracks", color: "#7B68EE" },
                "22": { label: "CT 200cc", color: "#DA70D6" },
                "666": { label: "Luminous 150cc", color: "#FFD700" },
                "667": { label: "Luminous Online TT", color: "#BDB76B" },
                "668": { label: "CTGP-C", color: "#32CD32" },
                "751": { label: "Versus", color: "#A9A9A9" },
                "-1": { label: "Regular", color: "#A9A9A9" },
                "": { label: "Private", color: "#A9A9A9" }, // fallback for "vs" or "bt"
                "69": { label: "IKW Default", color: "#ADD8E6" },
                "70": { label: "IKW Ultras VS", color: "#008080" },
                "71": { label: "IKW Countdown", color: "#00FFFF" },
                "72": { label: "IKW Bob-omb Blast", color: "#696969" },
                "73": { label: "IKW Infinite Accel", color: "#4B0082" },
                "74": { label: "IKW Banana Slip", color: "#FFFFE0" },
                "75": { label: "IKW Random Items", color: "#FF00FF" },
                "76": { label: "IKW Unfair Items", color: "#800000" },
                "77": { label: "IKW Blue Shell Madness", color: "#0000CD" },
                "78": { label: "IKW Mushroom Dash", color: "#2E8B57" },
                "79": { label: "IKW Bumper Karts", color: "#A52A2A" },
                "80": { label: "IKW Item Rampage", color: "#FA8072" },
                "81": { label: "IKW Item Rain", color: "#4169E1" },
                "82": { label: "IKW Shell Break", color: "#2E8B57" },
                "83": { label: "IKW Riibalanced", color: "#C0C0C0" },
                "875": { label: "OptPack 150cc", color: "#7CFC00" },
                "876": { label: "OptPack Online TT", color: "#556B2F" },
                "877": { label: "OptPack", color: "#000080" },
                "878": { label: "OptPack", color: "#000080" },
                "879": { label: "OptPack", color: "#000080" },
                "880": { label: "OptPack", color: "#000080" },
                "1312": { label: "WTP 150cc", color: "#008B8B" },
                "1313": { label: "WTP 200cc", color: "#483D8B" },
                "1314": { label: "WTP Online TT", color: "#8FBC8F" },
                "1315": { label: "WTP Item Rain", color: "#00CED1" },
                "1316": { label: "WTP STYD", color: "#9400D3" }
            };

            // handle history mode date changes
            function on_history_change() {
                if (HISTORY_TIMER){
                    clearTimeout(HISTORY_TIMER);
                }
                HISTORY_TIMER = setTimeout(change_history, 1000);
            }

            // add or subtract time in history mode
            function add_history(minutes) {
                let history_input = document.getElementById("history-input");
                let history_time = new Date(history_input.value).getTime();
                history_time += minutes * 60 * 1000;
                let timezone_offset = new Date().getTimezoneOffset() * 60000;
                history_time -= timezone_offset;
                history_input.value = new Date(history_time).toISOString().slice(0, 16);
                on_history_change();
            }

            // activate history mode and fetch data
            function change_history() {
                console.log("History mode enabled.");
                HISTORY_MODE = true;
                on_checkbox();
                fetch_rooms();
            }

            // disable history mode and return to live data
            function disable_history() {
                HISTORY_MODE = false;
                let params = new URL(window.location.href).searchParams;
                params.delete("time");
                window.history.replaceState(null, null, `?${params.toString()}`);
                fetch_rooms()
            }

            // disable room filter and show all rooms
            function disable_filter() {
                let params = new URL(window.location.href).searchParams;
                params.delete("room");
                window.history.replaceState(null, null, `?${params.toString()}`);
                reload_rooms();
            }
            
            // escape html characters
            function _escape(str){
                return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/(?:\r\n|\r|\n)/g, '');
            }

            // truncate and filter mii name
            function handle_mii_name(name){
                if (name.length > 10){
                    return name.substring(0, 10);
                }
                return filter_mii_name(_escape(name));
            }
            
            // check for wide characters in mii name
            function char_code_is_wide(char_code){
                if (char_code >= 0xF103 && char_code <= 0xF12F) {
                    return true;
                }
                if (char_code == 0x2026) {
                    return true;
                }
                return false;
            }

            // wrap wide characters for correct rendering
            function filter_mii_name(name){
                let new_name = "";
                let special_char = false;
                for (let i = 0; i < name.length; i++){
                    const char_code = name.charCodeAt(i);
                    if (char_code_is_wide(char_code)){
                        if (!special_char){
                            new_name += "<span class=\"wide-char\">";
                            special_char = true;
                        }
                    } else {
                        if (special_char){
                            new_name += "</span>";
                            special_char = false;
                        }
                    }
                    new_name += name[i];
                }

                if (special_char){
                    new_name += "</span>";
                }

                return new_name;
            }
            
            // handle fc highlight input change
            function on_fc_change(){
                const fc = document.getElementById("fc-input").value;
                localStorage.setItem("highlight-fc", fc);
                reload_rooms();
            }

            // fix rooms that are split due to connection issues
            function fix_split_rooms(rooms){
              let new_rooms = [];
              for (let room of rooms){
                  const player_keys = Object.keys(room.players);
                  room.split = false;
                  let player_data = [];
                  for (let i = 0; i < player_keys.length; i++){
                      player_data.push([]);
                  }
                  for (let i = 0; i < player_keys.length; i++){
                      const player = room.players[player_keys[i]];
                      const conn_map = player.conn_map;
                      for (let j = 0; j < conn_map.length; j++){
                          if (conn_map[j] != "0"){
                              let their_idx = j;
                              if (their_idx >= i){
                                  their_idx += 1;
                              }
                              player_data[i].push(their_idx);
                          }
                      }
                  }
                  let seen_players = [];
                  let sub_rooms = [];
                  for (let i = 0; i < player_data.length; i++){
                      if (seen_players.indexOf(i) != -1){
                          continue;
                      }
                      let new_room = JSON.parse(JSON.stringify(room));
                      new_room.players = {};
                      let new_players_idx = [];
                      let player_idx = i;
                      function recursive_add(idx){
                          if (seen_players.indexOf(idx) != -1){
                              return;
                          }
                          seen_players.push(idx);
                          let cur_connected = player_data[idx];
                          for (const connected_idx of cur_connected){
                              if (player_data[connected_idx].indexOf(idx) == -1){
                                  continue;
                              }
                              recursive_add(connected_idx);
                          }
                          new_players_idx.push(idx);
                      }
                      recursive_add(player_idx);
                      new_players_idx.sort((a, b) => a - b);
                      for (const idx of new_players_idx){
                          new_room.players[player_keys[idx]] = room.players[player_keys[idx]];
                      }
                      sub_rooms.push(new_room);
                  }
                  if (sub_rooms.length > 1){
                      sub_rooms.forEach((sub_room) => {
                          sub_room.split = true;
                          if (Object.keys(room.players)[0] in sub_room.players){
                              sub_room.split = false;
                          }
                      });
                      let fc_input = document.getElementById("fc-input").value;
                      let fc_list = [];
                      if (fc_input) {
                          fc_list.push(fc_input);
                      }
                      fc_list.push("4466-7667-0997", "3092-3771-7526");
                      let tmp = [];
                      for (let i = 0; i < sub_rooms.length; i++){
                          const room = sub_rooms[i];
                          let found = false;
                          for (const player_idx of Object.keys(room.players)){
                              const player = room.players[player_idx];
                              if (fc_list.includes(player.fc)){
                                  tmp.unshift(room);
                                  found = true;
                                  break;
                              }
                          }
                          if (!found){
                              tmp.push(room);
                          }
                      }
                      sub_rooms = tmp;
                      new_rooms = new_rooms.concat(sub_rooms);
                  } else {
                      new_rooms.push(room);
                  }
              }
              return new_rooms;
            }
          
            // filter and sort rooms based on highlighted fcs
            function filter_fc(rooms){
                let fc_raw = localStorage.getItem("highlight-fc");
                let fc_list = [];
                if (fc_raw) {
                    fc_list.push(fc_raw);
                }
                fc_list.push("4466-7667-0997", "3092-3771-7526");
                let new_rooms = [];
                for (let i = 0; i < rooms.length; i++){
                    const room = rooms[i];
                    let found = false;
                    for (const player_idx of Object.keys(room.players)){
                        const player = room.players[player_idx];
                        if (fc_list.includes(player.fc)){
                            new_rooms.unshift(room);
                            found = true;
                            break;
                        }
                    }
                    if (!found){
                        new_rooms.push(room);
                    }
                }
                return new_rooms;
            }

            let prev_uptime_update_date = null;
            let uptimes_timer = null;
            // update room uptime counters every second
            function update_uptimes(skip_reset = false){
                const time_spans = document.querySelectorAll("span[created]");
                if (!HISTORY_MODE || skip_reset || FIRST_LOAD){
                    FIRST_LOAD = false;
                    for (const time_span of time_spans){
                        const created = new Date(time_span.getAttribute("created"));
                        let now = new Date();
                        if (HISTORY_MODE) {
                            now = HISTORY_DATE;
                        }
                        const diff = now - created;
                        let seconds = Math.floor(diff / 1000);
                        let minutes = Math.floor(seconds / 60);
                        let hours = Math.floor(minutes / 60);
                        let days = Math.floor(hours / 24);
                        hours = hours - (days * 24);
                        minutes = minutes - (days * 24 * 60) - (hours * 60);
                        seconds = seconds - (days * 24 * 60 * 60) - (hours * 60 * 60) - (minutes * 60);
                        let padded_seconds = seconds.toString().padStart(2, "0");
                        let padded_minutes = minutes.toString().padStart(2, "0");
                        let padded_hours = hours.toString().padStart(2, "0");
                        let str = `${hours}:${padded_minutes}:${padded_seconds}`;
                        if (days > 0){
                            str = `${days}:${padded_hours}:${padded_minutes}:${padded_seconds}`;
                        }
                        time_span.textContent = str;
                    }
                }
                if (skip_reset){
                    return;
                }
                var timeout_ms = 1000;
                if (prev_uptime_update_date){
                    timeout_ms -= (Date.now() - prev_uptime_update_date);
                }
                prev_uptime_update_date = Date.now();
                if (uptimes_timer){
                    clearTimeout(uptimes_timer);
                }
                uptimes_timer = setTimeout(update_uptimes, timeout_ms);
            }

            // header stats flipper logic
            function start_header_stats_flipper(roomCount, playerCount) {
                if (HEADER_STATS_FLIPPER_TIMER) {
                    clearInterval(HEADER_STATS_FLIPPER_TIMER);
                    HEADER_STATS_FLIPPER_TIMER = null;
                }

                const showStats = el("header-stats-checkbox").checked;
                const container = el("header-stats");
                const roomEl = el("header-stats-rooms");
                const playerEl = el("header-stats-players");

                if (!showStats) {
                    container.classList.add('hidden');
                    return;
                }
                
                container.classList.remove('hidden');
                
                // update counts with excited span
                roomEl.innerHTML = `<span class="excited">${roomCount}</span> ${roomCount === 1 ? 'Room' : 'Rooms'}`;
                playerEl.innerHTML = `<span class="excited">${playerCount}</span> ${playerCount === 1 ? 'Player' : 'Players'}`;
                
                // Set initial state for fade-in
                roomEl.style.opacity = 0;
                playerEl.style.opacity = 0;

                const update_display = () => {
                    // check setting inside the loop
                    if (!el("header-stats-checkbox").checked) {
                        if (HEADER_STATS_FLIPPER_TIMER) clearInterval(HEADER_STATS_FLIPPER_TIMER);
                        HEADER_STATS_FLIPPER_TIMER = null;
                        container.classList.add('hidden');
                        return;
                    }
                    
                    HEADER_STATS_STATE = HEADER_STATS_STATE === 'rooms' ? 'players' : 'rooms'; // toggle state
                    
                    // Fade out both
                    roomEl.style.opacity = 0;
                    playerEl.style.opacity = 0;

                    setTimeout(() => {
                        // After fade out, switch display and fade in the correct one
                        if (HEADER_STATS_STATE === 'rooms') {
                            playerEl.style.display = 'none';
                            roomEl.style.display = 'inline';
                            roomEl.style.opacity = 1;
                        } else {
                            roomEl.style.display = 'none';
                            playerEl.style.display = 'inline';
                            playerEl.style.opacity = 1;
                        }
                    }, 300); // 300ms for fade out
                };
                
                // initial call
                update_display(); 
                // start interval
                HEADER_STATS_FLIPPER_TIMER = setInterval(update_display, 3000); // 3 sec toggle
            }
            
            // vr/br flipper logic
            function start_vrbr_flipper() {
                if (VRBR_FLIPPER_TIMER) {
                    clearInterval(VRBR_FLIPPER_TIMER);
                    VRBR_FLIPPER_TIMER = null;
                }
                
                if (el("vr-only-checkbox").checked) {
                    // if set to VR only, just set text once and do not start timer
                    const elements = document.querySelectorAll('.player-vrbr[data-vr][data-br]');
                     elements.forEach(el => {
                        el.textContent = `${el.dataset.vr} VR`;
                        el.style.opacity = 1;
                    });
                    return;
                }

                const update_vrbr_display = () => {
                    const elements = document.querySelectorAll('.player-vrbr[data-vr][data-br]');
                    
                    // check setting *inside* the loop, in case it changed
                    if (el("vr-only-checkbox").checked) {
                        if (VRBR_FLIPPER_TIMER) clearInterval(VRBR_FLIPPER_TIMER);
                        VRBR_FLIPPER_TIMER = null;
                        elements.forEach(el => {
                            el.textContent = `${el.dataset.vr} VR`;
                            el.style.opacity = 1;
                        });
                        return;
                    }
                    
                    VRBR_STATE = VRBR_STATE === 'vr' ? 'br' : 'vr'; // toggle state
                    
                    for (const el of elements) {
                        el.style.opacity = 0; // fade out
                    }
                    
                    setTimeout(() => {
                        for (const el of elements) {
                            if (VRBR_STATE === 'vr') {
                                el.textContent = `${el.dataset.vr} VR`;
                            } else {
                                el.textContent = `${el.dataset.br} BR`;
                            }
                            el.style.opacity = 1; // fade in
                        }
                    }, 300); // 300ms for fade out
                };
                
                // initial call
                update_vrbr_display(); 
                // start interval
                VRBR_FLIPPER_TIMER = setInterval(update_vrbr_display, 3000); // toggle every 3 seconds
            }

            // handle vr-only checkbox
            function on_vr_only_change() {
                const checked = el("vr-only-checkbox").checked;
                localStorage.setItem("vr-only", checked);
                
                if (checked) {
                    // if checked, stop the flipper and set all to VR
                    if (VRBR_FLIPPER_TIMER) {
                        clearInterval(VRBR_FLIPPER_TIMER);
                        VRBR_FLIPPER_TIMER = null;
                    }
                    const elements = document.querySelectorAll('.player-vrbr[data-vr][data-br]');
                    elements.forEach(el => {
                        el.textContent = `${el.dataset.vr} VR`;
                        el.style.opacity = 1;
                    });
                } else {
                    // if unchecked, restart the flipper
                    start_vrbr_flipper();
                }
            }
            
            // handle theme selection
            function on_theme_change() {
                const theme = el("theme-select").value;
                localStorage.setItem("theme", theme);
                apply_theme(theme);
            }

            // apply theme class to body
            function apply_theme(theme) {
                document.body.classList.remove("theme-blue", "theme-dark");
                if (theme === "blue") {
                    document.body.classList.add("theme-blue");
                } else if (theme === "dark") {
                    document.body.classList.add("theme-dark");
                }
                // 'orange' is the default, so no class is needed
            }

            // handle header stats visibility
            function on_header_stats_change() {
                const checked = el("header-stats-checkbox").checked;
                localStorage.setItem("show-header-stats", checked);
                
                const container = el("header-stats");
                container.classList.toggle('hidden', !checked);

                if (!checked && HEADER_STATS_FLIPPER_TIMER) {
                    // if turning off, stop the timer
                    clearInterval(HEADER_STATS_FLIPPER_TIMER);
                    HEADER_STATS_FLIPPER_TIMER = null;
                }
                // if turning on, reload_rooms will handle starting it
            }

            // handle room sort order
            function on_sort_order_change() {
                const sortOrder = el("sort-order-select").value;
                localStorage.setItem("sort-order", sortOrder);
                reload_rooms(); // re-sort and re-render
            }

            // handle auto-refresh checkbox
            function on_checkbox(){
                if (document.getElementById("timeout-checkbox").checked){
                    if (RELOAD_TIMER){
                        clearInterval(RELOAD_TIMER);
                    }
                    if (HISTORY_MODE){
                        RELOAD_TIMER = setInterval(on_checkbox, RELOAD_TIME);
                    } else {
                        RELOAD_TIMER = setInterval(fetch_rooms, RELOAD_TIME);
                    }
                } else {
                    if (RELOAD_TIMER){
                        clearInterval(RELOAD_TIMER);
                    }
                }
                localStorage.setItem("auto-reload", document.getElementById("timeout-checkbox").checked);
            }

            // handle show private rooms checkbox
            function on_private_checkbox() {
                const checkbox = document.getElementById("private-checkbox");
                localStorage.setItem("show-private", checkbox.checked);
                reload_rooms();
            }
            
            // handle openhost underline checkbox
            function on_openhost_checkbox() {
                const checkbox = document.getElementById("openhost-checkbox");
                localStorage.setItem("openhost", checkbox.checked);
                update_openhost_underline();
            }

            // update openhost underline style
            function update_openhost_underline() {
                let openhost_status = document.getElementById("openhost-checkbox").checked;
                document.querySelectorAll(".player-fc[openhost]").forEach((td) => {
                    if (openhost_status) {
                        td.classList.add("openhost");
                    } else {
                        td.classList.remove("openhost");
                    }
                });
            }

            // remove expired mii images from local storage
            function remove_expired_mii_images(){
                let remove_keys = [];
                for (let i = 0; i < localStorage.length; i++){
                    const key = localStorage.key(i);
                    if (key.startsWith("mii_")){
                        const mii_data = JSON.parse(localStorage.getItem(key));
                        if (Date.now() - mii_data[1] > EXPIRE_TIME){
                            remove_keys.push(key);
                        }
                    }
                    for (const key of remove_keys){
                        localStorage.removeItem(key);
                    }
                }
            }

            // get mii image from cache
            function get_cached_mii_image(mii_data){
                const mii_data_key = `mii_${mii_data}`;
                const mii_data_str = localStorage.getItem(mii_data_key);
                if (!mii_data_str){
                    return null;
                }
                const mii_data_arr = JSON.parse(mii_data_str);
                if (Date.now() - mii_data_arr[1] > EXPIRE_TIME){
                    localStorage.removeItem(mii_data_key);
                    return null;
                }
                return mii_data_arr[0];
            }

            // set mii image in cache
            function set_cached_mii_image(mii_data, mii_image){
                const mii_data_key = `mii_${mii_data}`;
                const mii_data_arr = [mii_image, Date.now()];
                localStorage.setItem(mii_data_key, JSON.stringify(mii_data_arr));
            }

            // apply mii image to all corresponding elements
            function apply_mii_image(mii_data, mii_image){
                set_cached_mii_image(mii_data, mii_image);
                const mii_elements = document.querySelectorAll(`img[mii-data="${mii_data}"]`)
                if (!mii_elements){
                    return;
                }
                for (const mii_element of mii_elements){
                    mii_element.src = mii_image;
                }
            }

            // fetch mii images from api
            async function fetch_mii_images(mii_data_list){
                let new_mii_data_list = [];
                for (const mii_data of mii_data_list){
                    let mii_image = get_cached_mii_image(mii_data);
                    if (mii_image){
                        apply_mii_image(mii_data, mii_image);
                    } else {
                        new_mii_data_list.push(mii_data);
                    }
                }
                if (new_mii_data_list.length > MAX_MIIS_PER_REQUEST){
                    const mii_data_list_copy = new_mii_data_list.slice();
                    new_mii_data_list = mii_data_list_copy.splice(0, MAX_MIIS_PER_REQUEST);
                    fetch_mii_images(mii_data_list_copy);
                }
                if (new_mii_data_list.length > 0){
                    const mii_data_response = await fetch("https://api.heyfordy.de/mii", {
                        method: "POST",
                        body: JSON.stringify(new_mii_data_list)
                    });
                    if (!mii_data_response.ok){
                        console.log("Error fetching Mii data from umapyoi.net");
                        return;
                    }
                    const mii_dict = await mii_data_response.json();
                    for (const mii_data of Object.keys(mii_dict)){
                        apply_mii_image(mii_data, mii_dict[mii_data]);
                    }
                }
            }

            // fetch footer versions
            async function fetch_versions() {
                try {
                    const rr_response = await fetch("https://api.heyfordy.de/rr_app/version-rr");
                    if (rr_response.ok) {
                        const rr_data = await rr_response.json();
                        el("rr-version").textContent = ` ‚Ä¢ v${rr_data.version}`;
                    }
                } catch (e) {
                    console.error("Failed to fetch RR version", e);
                }
                
                try {
                    const ww_response = await fetch("https://api.heyfordy.de/rr_app/version-ww");
                     if (ww_response.ok) {
                        const ww_data = await ww_response.json();
                        el("ww-version").textContent = ` ‚Ä¢ v${ww_data.version}`;
                    }
                } catch (e) {
                     console.error("Failed to fetch WW version", e);
                }
            }

            // initialize page on load
            async function on_load(){
                // modal logic
                const settingsBtn = el('settings-btn');
                const modal = el('settings-modal');
                const closeBtn = el('close-settings');
                
                settingsBtn.onclick = () => modal.classList.remove('hidden');
                closeBtn.onclick = () => modal.classList.add('hidden');

                // settings logic
                document.getElementById("timeout-checkbox").checked = localStorage.getItem("auto-reload") == "true";
                document.getElementById("fc-input").value = localStorage.getItem("highlight-fc") || "";
                
                let priv = localStorage.getItem("show-private");
                if (priv == null){
                    priv = true;
                } else {
                    priv = priv == "true";
                }
                document.getElementById("private-checkbox").checked = priv;
                
                let oh = localStorage.getItem("openhost");
                if (oh == null){
                    oh = true;
                } else {
                    oh = oh == "true";
                }
                document.getElementById("openhost-checkbox").checked = oh;
                
                // init new settings
                document.getElementById("vr-only-checkbox").checked = localStorage.getItem("vr-only") == "true";
                
                let showHeaderStats = localStorage.getItem("show-header-stats");
                if (showHeaderStats == null) {
                    showHeaderStats = true; // default on
                } else {
                    showHeaderStats = showHeaderStats == "true";
                }
                document.getElementById("header-stats-checkbox").checked = showHeaderStats;
                el("header-stats").classList.toggle('hidden', !showHeaderStats);
                
                const sortOrder = localStorage.getItem("sort-order") || "player_count";
                document.getElementById("sort-order-select").value = sortOrder;
                
                const theme = localStorage.getItem("theme") || "orange";
                document.getElementById("theme-select").value = theme;
                apply_theme(theme);

                // fetch footer versions
                fetch_versions();

                // history logic
                const url = new URL(window.location.href);
                const params = url.searchParams;
                const timestamp = params.get("time");
                if (timestamp){
                    HISTORY_MODE = true;
                    let timezone_offset = new Date().getTimezoneOffset() * 60000;
                    HISTORY_DATE = new Date(parseInt(timestamp) * 1000 - timezone_offset);
                    document.getElementById("history-input").value = HISTORY_DATE.toISOString().slice(0, 16);
                    change_history();
                    return;
                }
                fetch_rooms();
            }

            // main data fetching function
            async function fetch_rooms() {
                console.log("Loading data...");
                remove_expired_mii_images();
                let checkbox = document.getElementById("timeout-checkbox");
                let history_indicator = document.getElementById("history-indicator");
                let timestamp_part = "";
                if (HISTORY_MODE){
                    let datetime = document.getElementById("history-input").value;
                    let history_time = Math.max(0, new Date(datetime).getTime());
                    if (isNaN(history_time)){
                        history_time = 0;
                    }
                    let history_date = new Date(history_time);
                    HISTORY_DATE = history_date;
                    let unix_seconds = Math.floor(history_date.getTime() / 1000);
                    let params = new URL(window.location.href).searchParams
                    params.set("time", unix_seconds);
                    window.history.replaceState(null, null, `?${params.toString()}`);
                    timestamp_part = `?time=${unix_seconds}`;
                    checkbox.disabled = true;
                    history_indicator.style.display = "block";
                    el("rooms-container").innerHTML = "";
                    el("loading").style.display = "block";
                } else {
                    checkbox.disabled = false;
                    history_indicator.style.display = "none";
                }
                
                try {
                    const response = await fetch("https://api.heyfordy.de/rwfc" + timestamp_part);
                    if (!response.ok){
                        console.log("Error fetching room data from api.heyfordy.de");
                        cur_rooms = [];
                        reload_rooms();
                        return;
                    }

                    let response_data = await response.json();
                    let rooms;
                    let date = new Date();

                    if (HISTORY_MODE) {
                        if (response_data && typeof response_data.data !== 'undefined' && typeof response_data.timestamp !== 'undefined') {
                            date = new Date(response_data.timestamp * 1000);
                            rooms = response_data.data;
                        } else {
                            rooms = response_data;
                            date = HISTORY_DATE; 
                        }
                    } else {
                        rooms = response_data;
                    }

                    if (!Array.isArray(rooms)) {
                        console.error("Received data is not an array, setting to empty to prevent errors.", rooms);
                        rooms = [];
                    }

                    cur_rooms = rooms;
                    reload_rooms();

                    let timezone_offset = date.getTimezoneOffset() * 60000;
                    let local_time = new Date(date.getTime() - timezone_offset);
                    let history_input = document.getElementById("history-input");

                    if (history_input && !isNaN(local_time.getTime())) {
                        history_input.value = local_time.toISOString().slice(0, 16);
                    }
                } catch (error) {
                    console.error("Failed to fetch or process room data:", error);
                    cur_rooms = [];
                    reload_rooms();
                }
            }
            
            // update room display from current data
            async function reload_rooms(){
                let rooms = cur_rooms;
                if (!Array.isArray(rooms)) {
                    console.error("Cannot reload rooms, data is not an array.");
                    rooms = [];
                }
                
                const roomsContainer = el("rooms-container");
                roomsContainer.innerHTML = "";
                const url = new URL(window.location.href);
                const params = url.searchParams;
                const filter_room = params.get("room");
                let room_not_found = true;

                el("filter-indicator").style.display = filter_room ? "block" : "none";

                // apply sorting based on settings
                const sortOrder = localStorage.getItem("sort-order") || "player_count";
                
                // helper to get total mii count for sorting
                const getMiiCount = (room) => {
                    let count = 0;
                    for (const player_idx of Object.keys(room.players)) {
                        const player = room.players[player_idx];
                        count += ('mii' in player) ? player.mii.length : 1;
                    }
                    return count;
                };

                if (sortOrder === "time_created") {
                    // sort by creation time (oldest first)
                    rooms.sort((a, b) => new Date(a.created) - new Date(b.created));
                } else {
                    // default: sort by mii count (most first)
                    rooms.sort((a, b) => getMiiCount(b) - getMiiCount(a));
                }

                rooms = filter_fc(rooms); // pins highlighted rooms
                rooms = fix_split_rooms(rooms);
                
                let rooms_count = 0;
                let total_players_count = 0;

                for (const room of rooms) {
                    if (filter_room && room.id != filter_room){
                        continue;
                    }
                    if (!filter_room && !el("private-checkbox").checked && room.type != "anybody"){
                        continue;
                    }
                    rooms_count += 1;
                    room_not_found = false;
                    
                    // define room type icon
                    let room_type_icon = room.type == "anybody" ? "üåé" : "üîí";
                    
                    // define joinable status
                    let joinable = "‚úÖ Joinable";
                    let joinable_class = "joinable";
                    if (room.split) {
                        joinable = "‚õìÔ∏è Split Room";
                        joinable_class = "split-room";
                    }
                    else if (room.suspend) {
                        const current_room_player_count = Object.keys(room.players).length;
                        if (current_room_player_count >= 12) {
                            joinable = "‚ùå Not Joinable";
                            joinable_class = "not-joinable";
                        } else {
                            joinable = "üó∫Ô∏è Course selection";
                            joinable_class = "course-selection";
                        }
                    }

                    let room_no_players = 0;
                    
                    // get room type label (html) and text
                    var rk = room.rk || "";
                    var rk_key = rk.replace(/^(vs|bt)_/, "");
                    if (rk_key === "vs" || rk_key === "bt") rk_key = ""; // handle plain "vs" or "bt"
                    
                    var rk_label_html = "";
                    var rk_label_text_only = "";
                    
                    if (rk_key in ROOM_TYPES){
                        const type = ROOM_TYPES[rk_key];
                        rk_label_html = `<span title="${rk}" style="color: ${type.color};">${type.label}</span>`;
                        rk_label_text_only = type.label;
                    } else if (rk) {
                        rk_label_html = rk.toUpperCase();
                        rk_label_text_only = rk.toUpperCase();
                    } else if (ROOM_TYPES["-1"]) { // fallback for unknown
                         const type = ROOM_TYPES["-1"];
                         rk_label_html = `<span title="Unknown" style="color: ${type.color};">${type.label}</span>`;
                         rk_label_text_only = type.label;
                    }
                    
                    // define room link url
                    let room_params = new URL(window.location.href).searchParams;
                    room_params.set("room", room.id);
                    let room_link_href = `?${room_params.toString()}`;

                    // create room card base
                    let roomCard = document.createElement("div");
                    roomCard.className = "room-card";
                    
                    // create header
                    let roomHeader = document.createElement("div");
                    roomHeader.className = "room-card-header";
                    let header_text = rk_label_text_only ? `${rk_label_html} Room` : "";
                    roomHeader.innerHTML = `
                        <span class="room-name">${room_type_icon} ${header_text ? '| ' + header_text : ''}</span>
                        <a href="${room_link_href}" class="room-info-link" title="Filter this room">‚ìò</a>
                    `;
                    roomCard.appendChild(roomHeader);
                    
                    // create details container (filled after player loop)
                    let roomDetails = document.createElement("div");
                    roomDetails.className = "room-details";
                    roomCard.appendChild(roomDetails);

                    // create player list container
                    let playerList = document.createElement("div");
                    playerList.className = "player-list";
                    roomCard.appendChild(playerList);
                    
                    // create footer container (filled after player loop)
                    let roomFooter = document.createElement("div");
                    roomFooter.className = "room-card-footer";
                    roomCard.appendChild(roomFooter);
                    
                    // add card to main container
                    roomsContainer.appendChild(roomCard);

                    // sort players
                    const highlighted_fcs = (localStorage.getItem("highlight-fc") || "").split(',').map(fc => fc.trim()).filter(fc => fc);
                    const custom_highlighted_fcs = ["4466-7667-0997", "3092-3771-7526"];
                    const sorted_player_keys = Object.keys(room.players).sort((a, b) => {
                        const playerA = room.players[a];
                        const playerB = room.players[b];
                        const is_A_highlighted = highlighted_fcs.includes(playerA.fc) || custom_highlighted_fcs.includes(playerA.fc);
                        const is_B_highlighted = highlighted_fcs.includes(playerB.fc) || custom_highlighted_fcs.includes(playerB.fc);
                        if (is_A_highlighted && !is_B_highlighted) return -1;
                        if (!is_A_highlighted && is_B_highlighted) return 1;
                        const vrA = parseInt(playerA.ev, 10) || 0;
                        const vrB = parseInt(playerB.ev, 10) || 0;
                        return vrB - vrA;
                    });

                    // add players to list
                    for (const player_idx of sorted_player_keys) {
                        let no_miis = ('mii' in room.players[player_idx]) ? room.players[player_idx].mii.length : 1;
                        for (let cur_mii_idx = 0; cur_mii_idx < no_miis; cur_mii_idx++){
                            room_no_players++;
                            const player = room.players[player_idx];
                            
                            let playerRow = document.createElement("div");
                            playerRow.className = "player-row";
                            
                            let miiImg = document.createElement("img");
                            miiImg.className = "player-mii";
                            miiImg.width = 48; // Increased size
                            miiImg.height = 48; // Increased size
                            miiImg.alt = "Mii";
                            miiImg.src = "empty.png"; // placeholder
                            if ('mii' in player){
                                miiImg.setAttribute("mii-data", player.mii[cur_mii_idx].data);
                            }
                            playerRow.appendChild(miiImg);

                            let playerInfo = document.createElement("div");
                            playerInfo.className = "player-info";
                            
                            let playerName = document.createElement("div");
                            playerName.className = "player-name";
                            playerName.innerHTML = handle_mii_name('mii' in player ? player.mii[cur_mii_idx].name : player.name);
                            playerInfo.appendChild(playerName);
                            
                            let playerFc = document.createElement("div");
                            playerFc.className = "player-fc";
                            playerFc.textContent = cur_mii_idx == 0 ? player.fc : "Guest";
                            if (player["openhost"] && player.openhost == "true" && cur_mii_idx == 0) {
                                playerFc.setAttribute("openhost", "");
                                playerFc.title = "OpenHost enabled";
                            }
                            playerInfo.appendChild(playerFc);
                            playerRow.appendChild(playerInfo);
                            
							let playerVrBr = document.createElement("div");
							playerVrBr.className = "player-vrbr";
                            
                            if (cur_mii_idx === 0 && +player.ev && +player.eb) {
                                playerVrBr.dataset.vr = player.ev;
                                playerVrBr.dataset.br = player.eb;
                                // content set by flipper
                            } else {
                                playerVrBr.textContent = "üö´ VR/BR";
                            }

							playerRow.appendChild(playerVrBr);

                            // Player Menu Button
                            let playerMenuBtn = document.createElement("button");
                            playerMenuBtn.className = "player-menu-btn";
                            playerMenuBtn.innerHTML = "&gt;";
                            playerMenuBtn.title = "Player Menu";
                            
                            let playerMenu = document.createElement("div");
                            playerMenu.className = "player-menu";
                            
                            const fc = (cur_mii_idx == 0) ? player.fc : null;
                            
                            if (fc) {
                                playerMenuBtn.onclick = (e) => {
                                    e.stopPropagation();
                                    toggle_player_menu(playerMenu);
                                };

                                const isHighlighted = (fc === localStorage.getItem("highlight-fc"));

                                // Highlight Button
                                let btnHighlight = document.createElement("button");
                                btnHighlight.innerHTML = "‚≠êÔ∏è Set as highlighted FC";
                                btnHighlight.onclick = () => set_highlight_fc(fc);
                                
                                // Remove Highlight Button
                                let btnRemoveHighlight = document.createElement("button");
                                btnRemoveHighlight.innerHTML = "üö´ Remove as highlighted FC";
                                btnRemoveHighlight.className = "remove-highlight";
                                btnRemoveHighlight.onclick = () => remove_highlight_fc();
                                
                                if (isHighlighted && localStorage.getItem("highlight-fc")) {
                                    playerMenu.appendChild(btnRemoveHighlight);
                                } else {
                                    playerMenu.appendChild(btnHighlight);
                                }

                                // Stats Button
                                let btnStats = document.createElement("button");
                                btnStats.innerHTML = "üìä Player stats";
                                btnStats.onclick = () => open_player_stats(fc);
                                playerMenu.appendChild(btnStats);
                                
                                playerRow.appendChild(playerMenuBtn);
                                playerRow.appendChild(playerMenu);
                            }

								if (player.fc == localStorage.getItem("highlight-fc")){
                                playerRow.classList.add("highlighted");
                            }
                            if (custom_highlighted_fcs.includes(player.fc)){
                                playerRow.classList.add("custom-highlighted");
                            }

                            playerList.appendChild(playerRow);
                        }
                    }

                    // update total player count
                    total_players_count += room_no_players;

                    // update room details
                    var skip_reset = false;
					roomDetails.innerHTML = `
						<span class="room-player-count excited">${room_no_players}</span> ${room_no_players === 1 ? 'Player' : 'Players'} | 
						<span class="${joinable_class}">${joinable}</span>
					`;
                    
                    // update room footer
                    roomFooter.innerHTML = `
                        ID: <a href="${room_link_href}" class="room-link">${room.id}</a> ‚Ä¢ 
                        Uptime: <span created="${room.created}">0:00:00</span>
                    `;
                    
                    if (uptimes_timer){
                        skip_reset = true;
                    }
                    update_uptimes(skip_reset);
                }

                el("loading").style.display = "none";
                
                if (room_not_found && filter_room){
                    el("not-found-container").style.display = "block";
                    return;
                }

                el("not-found-container").style.display = "none";
                update_openhost_underline(); // update highlights
                
                start_vrbr_flipper(); // start/restart vr/br flipper
                
                // start/restart header stats flipper
                start_header_stats_flipper(rooms_count, total_players_count);

                // fetch mii images
                let mii_data_list = [];
                for (const img_element of document.querySelectorAll("img[mii-data]")){
                    mii_data_list.push(img_element.getAttribute("mii-data"));
                }
                
                if (el("timeout-checkbox").checked) {
                    if (RELOAD_TIMER){
                        clearInterval(RELOAD_TIMER);
                    }
                    if (HISTORY_MODE){
                        RELOAD_TIMER = setInterval(on_checkbox, RELOAD_TIME);
                    } else {
                        RELOAD_TIMER = setInterval(fetch_rooms, RELOAD_TIME);
                    }
                }
                fetch_mii_images(mii_data_list);
            }

            if (document.addEventListener)
                document.addEventListener('DOMContentLoaded', on_load, false)
            else window.onload = fetch_rooms
        </script>
    </body>
</html>
